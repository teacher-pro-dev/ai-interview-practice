<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI 기반 모의면접 프로그램</title>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap");
    :root {
      --bg: #f0f4f8;
      --panel: #ffffff;
      --panel-2: #f9fafb;
      --text: #333;
      --muted: #888;
      --primary: #4a90e2;
      --danger: #ff7070;
      --border: #eaecef;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); font-family: 'Noto Sans KR', system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial; color: var(--text); }
    .page { height: 100%; display: flex; align-items: center; justify-content: center; }
    .container { width: 96%; max-width: 1400px; height: 94vh; display: grid; grid-template-columns: 6fr 4fr; gap: 18px; }
    .video-section { background: var(--panel); border: 1px solid var(--border); border-radius: 16px; box-shadow: 0 10px 26px rgba(0,0,0,.06); padding: 18px; display: flex; flex-direction: column; position: relative; overflow: hidden; }
    .right { background: var(--panel-2); border: 1px solid var(--border); border-radius: 16px; box-shadow: 0 10px 26px rgba(0,0,0,.05); padding: 18px; display: flex; flex-direction: column; gap: 16px; overflow: hidden; }
    .title { font-size: 22px; font-weight: 700; color: var(--primary); margin: 0 0 6px; }
    .hint { font-size: 12px; color: var(--muted); margin: 0 0 12px; }
    .video-wrap { position: relative; flex: 1; min-height: 0; border-radius: 12px; overflow: hidden; background: #111; display: grid; place-items: center; }
    video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
    .overlay { position: absolute; inset: 0; pointer-events: none; display: flex; align-items: flex-start; justify-content: space-between; padding: 12px; }
    #timer { font-family: 'Courier New', monospace; background: rgba(255,255,255,.85); padding: 6px 10px; border-radius: 8px; font-weight: 700; }
    #countdown { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; font-size: 80px; color: white; text-shadow: 0 0 20px rgba(0,0,0,.55); background: rgba(0,0,0,.35); font-weight: 800; }
    .controls { display: flex; gap: 12px; margin-top: 12px; flex-wrap: wrap; }
    .btn { border: none; background: #eef3f7; padding: 10px 14px; border-radius: 12px; cursor: pointer; display: inline-flex; align-items: center; gap: 8px; font-weight: 600; box-shadow: 0 4px 14px rgba(0,0,0,.05); transition: transform .15s ease, background .2s ease; }
    .btn:hover { transform: translateY(-1px); background: #e9eef3; }
    .btn:disabled { opacity: .55; cursor: not-allowed; transform: none; }
    #recordBtn { background: var(--danger); color: #fff; }
    #recordBtn.recording { background: var(--primary); }
    .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 12px; box-shadow: inset 0 1px 0 rgba(255,255,255,.4); }
    .panel h3 { margin: 0 0 8px; font-size: 15px; display: flex; align-items: center; gap: 6px; }
    #transcriptBox { height: 180px; overflow: auto; padding: 10px; border-radius: 10px; background: #fff; border: 1px dashed #dfe3e7; font-size: 14px; line-height: 1.5; }
    #answerBox { height: 140px; overflow: auto; padding: 10px; border-radius: 10px; background: #fff; border: 1px dashed #dfe3e7; font-size: 14px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .input { width: 100%; border: 1px solid var(--border); border-radius: 10px; padding: 10px 12px; background: #fff; font-size: 14px; }
    .muted { color: var(--muted); font-size: 12px; }
    .sticky-actions { margin-top: auto; display: flex; gap: 10px; }
    .small { font-size: 12px; }
  </style>
</head>
<body>
  <div class="page">
    <div class="container">
      <section class="video-section">
        <h1 class="title">모의 면접 프로그램</h1>
        <p class="hint">카메라·마이크 권한 허용 후, <b>녹화</b> 버튼으로 시작하세요. 안드로이드 기기는 자동으로 대체 전사 모드로 동작합니다.</p>
        <div class="video-wrap">
          <video id="webcam" autoplay playsinline muted></video>
          <div class="overlay">
            <div id="timer">00:00</div>
          </div>
          <div id="countdown">3</div>
        </div>
        <div class="controls">
          <button id="recordBtn" class="btn">● 녹화</button>
          <button id="pauseBtn" class="btn" disabled>⏸️ 일시정지</button>
          <button id="saveBtn" class="btn" disabled>💾 영상 저장</button>
          <button id="permBtn" class="btn">🔒 권한 확인</button>
        </div>
      </section>

      <aside class="right">
        <div class="panel">
          <h3>질문 입력</h3>
          <input id="questionInput" class="input" placeholder="면접 질문을 입력하세요 (선택)" />
          <p class="muted small">질문은 전사/요약과 함께 저장되며, 실시간 전사에는 영향 없습니다.</p>
        </div>
        <div class="panel">
          <h3>실시간 내용 정리</h3>
          <div id="transcriptBox">음성 인식 결과가 여기에 표시됩니다…</div>
          <p id="sttModeMsg" class="muted small" style="margin-top:6px;"></p>
        </div>
        <div class="panel">
          <h3>모범 답안 / 요약</h3>
          <div id="answerBox">녹화 종료 후 서버 요약을 호출하도록 구성할 수 있습니다. (옵션)</div>
          <div class="sticky-actions">
            <button id="copyBtn" class="btn">📋 답변 복사</button>
            <button id="summBtn" class="btn">🪄 서버 요약 요청</button>
          </div>
        </div>
      </aside>
    </div>
  </div>

  <script>
    // ---------- 전역 상태 ----------
    const webcam = document.getElementById('webcam');
    const recordBtn = document.getElementById('recordBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const saveBtn = document.getElementById('saveBtn');
    const permBtn = document.getElementById('permBtn');
    const countdownEl = document.getElementById('countdown');
    const timerEl = document.getElementById('timer');
    const transcriptBox = document.getElementById('transcriptBox');
    const sttModeMsg = document.getElementById('sttModeMsg');
    const answerBox = document.getElementById('answerBox');
    const copyBtn = document.getElementById('copyBtn');
    const summBtn = document.getElementById('summBtn');
    const questionInput = document.getElementById('questionInput');

    let stream = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let seconds = 0, timerId = null;

    let fullTranscript = '';

    // STT 경로 분기
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let useFallbackSTT = false; // Android/Samsung/미지원 브라우저 폴백

    let isRecording = false;
    let isPaused = false;

    // 폴백용 오디오 전송 상태
    let fallbackRecorder = null;
    let fallbackIntervalId = null;

    // ---------- 권한 및 웹캠 ----------
    async function setupWebcam() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        webcam.srcObject = stream;
      } catch (err) {
        alert('카메라/마이크 접근이 거부되었습니다. 브라우저 설정에서 권한을 허용하세요.');
        console.error(err);
      }
    }

    async function checkPermissions() {
      try {
        const statuses = await navigator.permissions?.query({ name: 'microphone' }).catch(()=>null);
        const statuses2 = await navigator.permissions?.query({ name: 'camera' }).catch(()=>null);
        alert(`마이크: ${statuses?.state || '확인 불가'} / 카메라: ${statuses2?.state || '확인 불가'}`);
      } catch(e) {
        alert('이 브라우저는 권한 상태 조회를 지원하지 않습니다.');
      }
    }

    // ---------- 타이머 ----------
    function startTimer(){
      stopTimer();
      timerId = setInterval(()=>{
        seconds++;
        const mm = String(Math.floor(seconds/60)).padStart(2, '0');
        const ss = String(seconds%60).padStart(2, '0');
        timerEl.textContent = `${mm}:${ss}`;
      }, 1000);
    }
    function stopTimer(){ if (timerId) clearInterval(timerId); timerId = null; }
    function resetTimer(){ seconds = 0; timerEl.textContent = '00:00'; }

    // ---------- STT 분기 판단 ----------
    (function decideSTTPath(){
      const ua = navigator.userAgent || '';
      const isAndroid = /Android/i.test(ua);
      const isSamsungInternet = /SamsungBrowser/i.test(ua);
      useFallbackSTT = !SpeechRecognition || isAndroid || isSamsungInternet;
      sttModeMsg.textContent = useFallbackSTT
        ? '이 기기는 브라우저 내장 음성인식이 미지원이거나 제한되어 대체 전사 모드(3초 청크 업로드)를 사용합니다.'
        : '이 기기는 브라우저 내장 음성인식(Web Speech API)으로 실시간 전사가 동작합니다.';
    })();

    // ---------- Web Speech API 경로 ----------
    function initRecognition(){
      if (!SpeechRecognition) return;
      recognition = new SpeechRecognition();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'ko-KR';

      recognition.onresult = (event)=>{
        let interim = '', finalTxt = '';
        for (let i=0; i<event.results.length; i++) {
          const r = event.results[i];
          const t = r[0].transcript;
          if (r.isFinal) finalTxt += t; else interim += t;
        }
        if (finalTxt) fullTranscript = (fullTranscript + ' ' + finalTxt).trim();
        transcriptBox.innerHTML = (fullTranscript || '') + (interim ? ` <i style="color:#999;">${interim}</i>` : '');
      };
      recognition.onerror = (e)=>{
        console.warn('SpeechRecognition error:', e.error);
      };
    }

    // ---------- 폴백: 3초마다 오디오 청크 업로드 ----------
    async function startFallbackTranscription(){
      // 오디오만 별도로 추출
      const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      fallbackRecorder = new MediaRecorder(audioStream, { mimeType: 'audio/webm' });
      let pending = [];
      fallbackRecorder.ondataavailable = (e)=>{ if (e.data && e.data.size>0) pending.push(e.data); };
      fallbackRecorder.start(1000);
      fallbackIntervalId = setInterval(async ()=>{
        if (!isRecording) return;
        if (!pending.length) return;
        const blob = new Blob(pending, { type: 'audio/webm' });
        pending = [];
        try {
          const form = new FormData();
          form.append('file', blob, `chunk-${Date.now()}.webm`);
          form.append('lang', 'ko');
          const q = (questionInput.value || '').trim();
          if (q) form.append('question', q);
          const res = await fetch('/api/transcribe', { method: 'POST', body: form });
          if (!res.ok) throw new Error('STT 서버 오류: ' + res.status);
          const data = await res.json();
          const text = (data.text || '').trim();
          if (text) {
            fullTranscript = (fullTranscript + ' ' + text).trim();
            transcriptBox.innerHTML = fullTranscript + ' <i class="small muted">(처리중)</i>';
          }
        } catch(err){ console.error(err); }
      }, 3000);
    }
    function stopFallbackTranscription(){
      try {
        if (fallbackIntervalId) clearInterval(fallbackIntervalId);
        fallbackIntervalId = null;
        if (fallbackRecorder && fallbackRecorder.state !== 'inactive') fallbackRecorder.stop();
      } catch(e){ console.warn(e); }
      finally { fallbackRecorder = null; }
    }

    // ---------- 녹화 핸들러 ----------
    recordBtn.addEventListener('click', async ()=>{
      // 현재 녹화 중이면 정지
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        isRecording = false;
        mediaRecorder.stop();
        if (!useFallbackSTT) { try { recognition && recognition.stop(); } catch(_){} }
        else { stopFallbackTranscription(); }
        recordBtn.classList.remove('recording');
        recordBtn.textContent = '● 녹화';
        saveBtn.disabled = false;
        pauseBtn.disabled = true;
        isPaused = false;
        stopTimer();
        return;
      }

      // 시작 카운트다운
      let count = 3;
      countdownEl.textContent = count;
      countdownEl.style.display = 'flex';
      recordBtn.disabled = true;

      const tick = setInterval(async ()=>{
        count--;
        if (count>0) { countdownEl.textContent = count; return; }
        clearInterval(tick);
        countdownEl.style.display = 'none';
        recordBtn.disabled = false;

        // 실제 녹화 시작
        recordedChunks = [];
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.ondataavailable = (e)=>{ if (e.data.size>0) recordedChunks.push(e.data); };
        mediaRecorder.start();

        // STT 시작
        isRecording = true;
        fullTranscript = '';
        transcriptBox.textContent = '음성 인식이 시작되었습니다…';

        if (!useFallbackSTT) {
          if (!recognition) initRecognition();
          try { recognition && recognition.start(); } catch(_){}
        } else {
          await startFallbackTranscription();
        }

        recordBtn.classList.add('recording');
        recordBtn.textContent = '■ 종료';
        saveBtn.disabled = true;
        pauseBtn.disabled = false;
        resetTimer();
        startTimer();
      }, 1000);
    });

    // 일시정지/재개
    pauseBtn.addEventListener('click', ()=>{
      if (!mediaRecorder) return;
      if (isPaused) {
        mediaRecorder.resume();
        if (!useFallbackSTT) { try { recognition && recognition.start(); } catch(_){} }
        startTimer();
        pauseBtn.textContent = '⏸️ 일시정지';
      } else {
        mediaRecorder.pause();
        if (!useFallbackSTT) { try { recognition && recognition.stop(); } catch(_){} }
        stopTimer();
        pauseBtn.textContent = '▶️ 재개';
      }
      isPaused = !isPaused;
    });

    // 영상 저장
    saveBtn.addEventListener('click', ()=>{
      if (!recordedChunks.length) return alert('저장할 영상이 없습니다.');
      const blob = new Blob(recordedChunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const ts = new Date().toISOString().replace(/[:.]/g, '-');
      a.download = `interview-${ts}.webm`;
      a.click();
      setTimeout(()=> URL.revokeObjectURL(url), 1000);
    });

    // 권한 확인
    permBtn.addEventListener('click', checkPermissions);

    // 요약(옵션 서버 호출)
    summBtn.addEventListener('click', async ()=>{
      const text = fullTranscript.trim();
      if (!text) return alert('요약할 전사 텍스트가 없습니다.');
      try {
        const res = await fetch('/api/summarize', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ transcript: text, question: questionInput.value || '' }) });
        if (!res.ok) throw new Error('요약 서버 오류: ' + res.status);
        const data = await res.json();
        answerBox.textContent = (data.summary || '요약 결과가 비어 있습니다.');
      } catch(err){
        console.error(err);
        alert('요약 요청 중 오류가 발생했습니다. 서버 구성을 확인하세요.');
      }
    });

    // 복사
    copyBtn.addEventListener('click', async ()=>{
      const txt = answerBox.textContent || '';
      if (!txt) return;
      try { await navigator.clipboard.writeText(txt); copyBtn.textContent = '✅ 복사 완료'; setTimeout(()=> copyBtn.textContent='📋 답변 복사', 1800); }
      catch(err){ alert('복사 실패: ' + err); }
    });

    // 초기화
    window.addEventListener('load', setupWebcam);
  </script>
</body>
</html>
